# Java Concurrency in Practice

## 线程安全性

线程安全性的定义中，最核心的概念就是正确性。正确性的含义是，某个类的行为与其规范完全一致。

当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。

无状态对象一定是线程安全的。

### 原子性

递增操作`++count`是一个复合操作。这是一个“读取-修改-写入”的操作序列，并且其结果状态依赖于之前的状态。

#### 竞态条件

当某个计算的正确性取决于多个线程的交替执行时序时，就会发生竞态条件。（正确的结果取决于运气）

最常见的竞态条件类型就是：

+ 先检查后执行(Check-Then-Act)：通过一个可能失效的观测结果来决定下一步动作。

  常见的情况：

  + 延迟初始化

    ```java
    public class LazyInitRace {
        private ExpensiveObject instance = null;
        public ExpensiveObject getInstance() {
            if (instance == null) instance = new ExpensiveObject();
            return instance;
        }
    }
    ```

  + 读取-修改-写入
        递增操作

当在无状态类中添加一个状态时，如果该状态完全由线程安全的对象来管理，那么这个类仍然是线程安全的。

当状态变量的数量由一个变为多个时，并不会像由零个变为一个那样简单。

### 加锁机制

#### 内置锁

内置锁是可重入的。某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。“重入”意味着获取锁的操作的粒度是“线程”，而不是“调用”。

### 用锁来保护状态

锁能够使其保护的代码路径以串行形式访问，因此可以通过锁来构造一些协议以实现对共享状态的独占访问。

仅仅将复合操作封装到一个同步代码块中是不够的。如果用同步来协调对某个变量的访问，那么在访问这个变量的所有位置上都需要使用同步。而且，当使用锁来协调对某个变量的访问时，在访问变量的所有位置上都要使用同一个锁。

如果在添加新的方法或代码路径时忘记了使用同步，那么这种加锁协议会很容易被破坏。

如果只是将每个方法都作为同步方法，例如`Vector`，那么并不足以确保`Vector`上复合操作都是原子的：`if (!vector.contains(element)) vector.add(element)`;

虽然`contains`和`add`等方法都是原子方法。但在上面这个“如果不存在则添加”的操作中仍然存在竞态条件。虽然`synchronized`方法可以确保单个操作的原子性，但如果要把多个操作合并为一个复合操作，还是需要额外的加锁机制。

### 活跃性和性能

要判断同步代码块的合理大小，需要在各种设计需求之间进行权衡，包括安全性（必须得到满足）、简单性和性能。

## 对象的共享

加锁的含义不仅仅局限于互斥行为，还包括内存可见性。

加锁机制既可以确保可见性又可以确保原子性，而`volatile`变量只能确保可见性。

当某个对象逸出后，你必须假设有某个类或线程可能会误用该对象。这正是需要使用封装的最主要原因：封装能够使得对程序的正确性进行分析变得可能，并使得无意中破坏设计约束条件变得更难。

### 不变性

在Java语言规范和Java内存模型中都没有给出不可变性的正式定义，但不可变性并不等于将对象中所有的域都声明为final类型，即使对象中所有的域都是final类型的，这个对象也仍然是可变的，因为在final类型的域中可以保存对可变对象的引用。

当满足以下条件时，对象才是不可变的：

+ 对象创建以后其状态就不能修改。
+ 对象的所有域都是final类型。
+ 对象是正确创建的（在对象的创建期间，this引用没有逸出）。

在不可变对象的内部仍可以使用可变对象来管理它们的状态。（这里主要注意第一个条件）

```java
public final class ThreeStooges {
    private final Set<String> stooges = new HashSet<String>();
    public ThreeStooges() {
        stooges.add("Moe");
    }
    public boolean isStooge(String name) {
        return stooges.contains(name);
    }
}
```

即使一个对象是可变的，通过将对象的某些域声明为final类型，仍然可以简化对其状态的推理，因为限制对象的可变性，相当于限制了它的可能状态集。

正如“除非需要更高的可见性，否则应将所有的域都声明为私有域”是一个良好的编程习惯，“除非需要某个域是可变的，否则应将其声明为final域”也是一个良好的编程习惯。

#### 不可变对象与初始化安全性

Java内存模型为不可变对象的共享提供了一种特殊的初始化安全性保证。

> 对于含有final域的对象，JVM必须保证对对象的初始引用在构造函数之后执行，不能乱序执行（out of order），也就是可以保证一旦你得到了引用，final域的值都是完成了初始化的，也就是书中所说的“初始化安全性”的保证。[来源](https://blog.csdn.net/ll530304349/article/details/52629254)

## 对象的组合

### 设计线程安全的类

如果对象中所有的域都是基本类型的变量，那么这些域将构成对象的全部状态。

如果在对象的域中引用了其他对象，那么该对象的状态将包含被引用对象的域。例如，`LinkedList`的状态就包括该链表中所有节点对象的状态。
