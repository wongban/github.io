# Java Concurrency in Practice

线程的优势：

+ **发挥多处理器的强大能力**。单线程程序同时只能在一个处理器上运行，其他资源将被浪费。多线程程序可以同时在多个处理器上执行。提升系统吞吐率。
+ **建模的简单性**。只包含一种类型的任务比包含多种不同类型任务的程序要更易于编写，错误更少，也更容易测试。如果为模型中每种类型的任务都分配一个专门的线程，那么可以形成一种串行执行的假象。
+ **异步时间的简化处理**。
+ **相应更灵敏的用户界面**。

线程的风险：

+ **安全性问题**。在没有充足同步的情况下，多个线程中的操作执行顺序时不可预测的。
+ **活跃性问题**。某个操作无法继续执行下去（死锁、饥饿、活锁）。
+ **性能问题**。挂起活跃线程并转而运行另一个线程会频繁地出现上下文切换操作。

## 线程安全性

要编写线程安全的代码，其核心在于要对状态（特别是对共享的和可变的）访问操作进行管理。

`HashMap`的状态不仅存储在`HashMap`对象本身，还存储在许多`Map.Entry`对象中。在对象的状态中包含了任何可能影响其外部可见行为的数据。

同步机制可以协同对象可变状态的访问。“同步”术语包括`synchronized`，`volatile`，显示锁以及原子变量。

### 安全性

线程安全性的定义中，最核心的概念就是正确性。正确性的含义是，某个类的行为与其规范完全一致，“所见即所知”。

**定义**：当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类时线程安全的。

在**线程安全类**的对象实例上执行的任何串行或并行操作都不会使对象处于无效状态。线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施。

无状态对象一定是线程安全的。

### 原子性

递增操作`++count`是一个复合操作。这是一个“读取-修改-写入”的操作序列，并且其结果状态依赖于之前的状态。

#### 竞态条件

当某个计算的正确性取决于多个线程的交替执行时序时，就会发生竞态条件。（正确的结果取决于运气）。最常见的竞态条件类型就是“先检查后执行（Check-Then-Act）”操作，通过一个可能失效的观测结果来决定下一步动作。

+ 延迟初始化

    ```java
    public class LazyInitRace {
        private ExpensiveObject instance = null;
        public ExpensiveObject getInstance() {
            // 多个线程有可能同时进入if并生成多个对象
            if (instance == null) instance = new ExpensiveObject();
            return instance;
        }
    }
    ```

+ 读取-修改-写入
    递增操作

当在无状态类中添加一个状态时，如果该状态完全由线程安全的对象来管理，那么这个类仍然是线程安全的。

当状态变量的数量由一个变为多个时，并不会像由零个变为一个那样简单。

### 加锁机制

#### 内置锁

内置锁是可重入的。某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。“重入”意味着获取锁的操作的粒度是“线程”，而不是“调用”。

### 用锁来保护状态

锁能够使其保护的代码路径以串行形式访问，因此可以通过锁来构造一些协议以实现对共享状态的独占访问。

仅仅将复合操作封装到一个同步代码块中是不够的。如果用同步来协调对某个变量的访问，那么在访问这个变量的所有位置上都需要使用同步。而且，当使用锁来协调对某个变量的访问时，在访问变量的所有位置上都要使用同一个锁。

如果在添加新的方法或代码路径时忘记了使用同步，那么这种加锁协议会很容易被破坏。

如果只是将每个方法都作为同步方法，例如`Vector`，那么并不足以确保`Vector`上复合操作都是原子的：`if (!vector.contains(element)) vector.add(element)`;

虽然`contains`和`add`等方法都是原子方法。但在上面这个“如果不存在则添加”的操作中仍然存在竞态条件。虽然`synchronized`方法可以确保单个操作的原子性，但如果要把多个操作合并为一个复合操作，还是需要额外的加锁机制。

### 活跃性和性能

要判断同步代码块的合理大小，需要在各种设计需求之间进行权衡，包括安全性（必须得到满足）、简单性和性能。

## 对象的共享

加锁的含义不仅仅局限于互斥行为，还包括内存可见性。

加锁机制既可以确保可见性又可以确保原子性，而`volatile`变量只能确保可见性。

当某个对象逸出后，你必须假设有某个类或线程可能会误用该对象。这正是需要使用封装的最主要原因：封装能够使得对程序的正确性进行分析变得可能，并使得无意中破坏设计约束条件变得更难。

### 不变性

在Java语言规范和Java内存模型中都没有给出不可变性的正式定义，但不可变性并不等于将对象中所有的域都声明为final类型，即使对象中所有的域都是final类型的，这个对象也仍然是可变的，因为在final类型的域中可以保存对可变对象的引用。

当满足以下条件时，对象才是不可变的：

+ 对象创建以后其状态就不能修改。
+ 对象的所有域都是final类型。
+ 对象是正确创建的（在对象的创建期间，this引用没有逸出）。

在不可变对象的内部仍可以使用可变对象来管理它们的状态。（这里主要注意第一个条件）

```java
public final class ThreeStooges {
    private final Set<String> stooges = new HashSet<String>();
    public ThreeStooges() {
        stooges.add("Moe");
    }
    public boolean isStooge(String name) {
        return stooges.contains(name);
    }
}
```

即使一个对象是可变的，通过将对象的某些域声明为final类型，仍然可以简化对其状态的推理，因为限制对象的可变性，相当于限制了它的可能状态集。

正如**除非需要更高的可见性，否则应将所有的域都声明为私有域**是一个良好的编程习惯，**除非需要某个域是可变的，否则应将其声明为`final`域**也是一个良好的编程习惯。

#### 不可变对象与初始化安全性

Java内存模型为不可变对象的共享提供了一种特殊的初始化安全性保证。

> 对于含有final域的对象，JVM必须保证对对象的初始引用在构造函数之后执行，不能乱序执行（out of order），也就是可以保证一旦你得到了引用，final域的值都是完成了初始化的，也就是书中所说的“初始化安全性”的保证。[来源](https://blog.csdn.net/ll530304349/article/details/52629254)

## 对象的组合

### 设计线程安全的类

如果对象中所有的域都是基本类型的变量，那么这些域将构成对象的全部状态。

如果在对象的域中引用了其他对象，那么该对象的状态将包含被引用对象的域。例如，`LinkedList`的状态就包括该链表中所有节点对象的状态。

## 中断和关闭

阻塞库方法(`Thread.sleep` `Object.wait`)都会检查线程何时中断，并且在发现中断时提前返回。它们在响应中断时执行的操作包括：清除中断状态，抛出`InterruptedException`，表示阻塞操作由于中断而提前结束。

## 线程池的使用

对于**计算密集型**（消化CPU资源）的任务，在拥有N个处理器的系统上，当线程池的大小为N+1时，通常能实现最优的利用率。（即使当计算密集型的线程偶尔由于页缺失故障或者其他原因而暂停时，这个“额外”的线程也能确保CPU的时钟周期不会被浪费。）。对于包含**I/O操作**或者其他**阻塞操作**的任务，由于线程并不会一直执行，因此线程池的规模应该更大。

## 显式锁

### Lock与ReentrantLock

```java
public interface Lock {
    // 无条件锁，等于使用synchronize
    void lock();
    void lockInterruptibly() throws InterruptedException;
    // 可轮询，可定时锁
    boolean tryLock();
    boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException;
    void unlock();
    Condition newCondition();
}
```

内置锁在功能上存在一些局限性（无法实现非阻塞结构）：

+ 无法中断一个正在等待获取锁的线程
+ 试图获得锁而不愿意永远等待它

`Lock`必须在`finally`块中释放锁。否则在被保护的代码中抛出异常，那么这个锁永远都无法释放。还必须考虑异常时，对象可能处于不一致状态（恢复不变性条件）。

`ReentrantLock`不能完全替代`synchronized`的原因：它更加危险，离开代码块不会自动清除锁。应该作为一种高级工具，在需要高级功能时才使用：可定时、可轮询、可中断，公平队列，非块结构。

#### 轮询锁与定时锁

内置锁出现死锁时恢复程序的唯一方法是重启，防止死锁的唯一方法是在构造程序时避免出现不一致的锁顺序。可定时、可轮询的锁提供了另一种选择：避免死锁发生。

轮询锁会在调用后立即返回，判断是否获得锁。可以使用轮询的方式来获取锁，并在循环了加上时间限制，来避免死锁发生。定时锁能如果不能在指定时间内给出结果，就会返回。

### 公平性

`ReentrantLock`的构造函数提供了两种公平性选择：创建非公平锁（默认）或公平锁。

+ 公平锁：线程按照它们发出请求的顺序来获得锁
+ 非公平锁：线程请求锁时，如果在发出请求的同时锁状态可以用，将跳过队列中的线程并获得锁（插队）

在非公平锁中，只有当锁被某个线程持有时，新发出请求的线程才会被放入队列中。

使用非公平锁的原因：可以提高性能。如果队列存在线程等待获得锁，接下来的请求也将会放到的队列中排队等待（挂起）。挂起-恢复这个过程存在着开销，而极大地降低性能。如果使用非公平锁，那么在发出请求时如果可用将直接获得，跳过了挂起-恢复的过程。在实际情况中，通常只需要保证被阻塞的线程能最终获得锁即可。依赖于公平的排队算法来确保正确性的情况并不常见。（不必要的话，不要为公平性付出代价）

恢复一个被挂起的线程与该线程真正开始运行之间存在着严重的延迟。

内置锁和默认的`ReentrantLock`一样不会提供确定的公平性保证。Java语言规范没有要求JVM以公平的方式来实现内置锁，而在各种JVM中也没有这样做。

### 读-写锁

```java
public interface ReadWriteLock {
    Lock readLock();
    Lock writeLock();
}
```

`ReentrantLock`是一种互斥锁，互斥通常是一种过于强硬的加锁机制，保守的加锁策略。虽然可以避免“写/写”，“写/读”冲突，但同样也避免了“读/读”冲突。而有些数据结构大多数访问操作都是读操作，允许多个执行读线程同时访问，将会提升性能。只要每个线程都能确保取到最新的数据，并且在读取数据时不会有其他的线程修改数据，那么就不会发生问题。一个资源可以被多个读操作访问，或者被一个写操作访问，但两者不能同时进行。

> `volatile`也能在一写多读的情况提供跟`ReadWriteLock`一样的特性，但`ReadWriteLock`还可以在多个写线程的情况下使用，写线程互斥。

与`Lock`一样，`ReadWriteLock`可以采用多种实现方式，这些方式在性能、调度保证、优先性、公平性以及加锁语义等方面可能有所不同：

+ **释放优先**。写入操作释放锁时，队列同时存在读写线程，应该优先选择哪种线程，还是最先发出请求的线程？
+ **读线程插队**。锁由读线程持有，但有写线程正在等待，新到达的读线程能否立即获得访问权，还是在写线程后面等待？允许将提高并发性，却可能造成写线程发生饥饿问题。
+ **重入性**。读锁和写锁是否是可重入的？
+ **降级**。持有写锁的线程能否在不释放的情况下获得读锁？（写锁“降级”为读锁），同时不允许其他写线程修改被保护的资源。
+ **升级**。读锁优先其他读写线程升级为写锁。大多数不支持升级，容易造成死锁。

```java
public class ReadWriteMap<K, V> {
    private final Map<K, V> map;
    private final ReadWriteLock lock = new ReentrantReadWriteLock();
    private final Lock r = lock.readLock();
    private final Lock w = lock.writeLock();

    public V put(K key, V value) {
        w.lock();
        try {
            return map.put(key, value);
        } finally {
            w.unlock();
        }
    }

    public V get(Object key) {
        r.lock();
        try {
            return map.get(key);
        } finally {
            r.unlock();
        }
    }
}
```

## 构建自定义的同步工具

构建状态依赖类的最简单方法是在类库中现有状态依赖类基础上构造。如果没有提供需要的功能，可以使用底层机制来构造自己的同步机制：条件队列、显式的`Condition`对象、`AbstractQueuedSynchronizer`框架。

### 状态依赖性的管理

并发对象上状态依赖的方法有时可以在不满足前置条件时失败，但通常有更好的替代方法：等待（阻塞）前置条件变为真。

构成前置条件的状态变量必须由对象的锁保护，以便在测试前置条件时保持不变。如果前置条件不成立，则必须释放锁定，以便另一个线程可以修改对象状态。

使用轮询和休眠虽然可以解决状态依赖问题，但效率不高：

```java
public void put(V v) throws InterruptedException {
    while (true) {
        synchronized (this) {
            if (!isNull()) {
                doPut(v);
                return;
            }
        }
        Thread.sleep(SLEEP_GRANULARITY);
        // 不进入休眠，则被成为忙等待或自旋等待。时间过长将会消耗大量CPU时间
        // 进入休眠，如果状态在`sleep`后就立即发生变化，将存在不必要的休眠时间
    }
}
```

内置的条件队列可以使线程一直阻塞，直到对象进入某个线程可以继续执行的状态，并且当被阻塞的线程可以执行时再唤醒它们。这种做法更高效（当缓存状态没有发生变化时，线程醒来的次数将更少），响应性也更高（当发生特定状态变化时将立即醒来）。

#### 条件队列

“条件队列”：使得一组线程（等待线程集）能够通过某种方式来等待特定的条件变成真。传统队列的元素是数据，条件队列的元素是正在等待相关条件的线程。

正如每个Java对象都可以作为一个锁，每个对象同样可以作为一个条件队列，`Object`中的`wait`、`notify`、`notifyAll`方法构成内部条件队列的API。对象的内部锁和它的内部条件队列是相关的：要调用对象X上的任何条件队列方法，必须在X上持有锁。这是因为“等待基于状态的条件的机制”与“保持状态一致性的机制”必然是紧密绑定的。

`Object.wait`会自动释放锁，并请求操作系统挂起当前进程，从而使其他线程能够获得这个锁并修改对象的状态。当被挂起的线程醒来时，它将在返回之前重新获取锁。

```java
// 阻塞直到：not-full
public synchronized void put(V v) throws InterruptedException {
    while (isFull())
        wait();
    doPut(v);
    notifyAll();
}

// 阻塞直到:not-empty
public synchronized V take() throws InterruptedException {
    while (isEmpty())
        wait();
    V v = doTake();
    notifyAll();
    return v;
}
```

### 使用条件队列

**条件谓词**是使某个操作成为状态依赖操作的前提条件。在有界缓存中，只有当`!isEmpty()`时，`take`才能执行，否则必须等待。对`take`来说，它的条件谓词就是`!isEmpty()`。

#### 过早唤醒

内置条件队列可以与多个条件谓词一起使用，例如：`isFull()`、`isEmpty()`。当一个线程由于调用`notifyAll`而醒来时，并不意味该线程的条件谓词已变成真了。

+ 可能在调用`notifyAll`时是真的，但在重新获取锁时再次变为假（其他线程优先获取锁并修改对象状态）。
+ 可能是另一个条件谓词变成了真。

所以当线程从`wait`唤醒时，都必须再次测试条件谓词。

#### 丢失的信号

活跃性故障的一种。在调用`wait`前没有检查条件谓词，就会导致信号丢失。

#### 通知

每当在等待一个条件时，一定要确保在条件谓词变为真时通过某种方式发出通知。

+ `notify`会从这个条件队列上等待的多个线程中选择一个唤醒
+ `notifyAll`会唤醒所有这个条件队列上等待的线程

如果条件队列持有多个条件谓词，使用`notify`将是一种危险的操作，单一的通知很容易导致类似于信号丢失的问题（信号被劫持）。

使用`notify`的条件：

1. **所有等待线程的类型都相同**：只有一个条件谓词与条件队列相关。并且每个线程在从`wait`返回后将执行相同的操作。
2. **单进单出**：在条件变量上的每次通知，最多只能唤醒一个线程来执行。

条件通知：

```java
public synchronized void put(V v) throws InterruptedException {
    while (isFull())
        wait();
    boolean wasEmpty = isEmpty();
    doPut(v);
    // 由空变为非空
    if (wasEmpty())
        notifyAll();
}
```

单次通知和条件通知都属于优化措施。

### 显式的Condition对象

内置条件队列存在一些缺陷。每个内置锁都只能有一个相关联的条件队列，而条件队列可能有多个条件谓词。`notifyAll`无法单一唤醒某一类型的线程。

一个`Condition`和一个`Lock`关联在一起，如同一个条件队列关联一个内置锁。`Condition`比内置条件队列提供更丰富的功能：每个锁存在多个等待、条件等待可以是可中断或不可中断的、基于时限的等待，以及公平的或非公平的队列操作。

```java
protected final Lock lock = new ReentrantLock();
private final Condition notFull = lock.newCondition();
private final Condition notEmpty = lock.newCondition();
private final T[] items = (T[]) new Object[BUFFER_SIZE];
private int tail, head, count;

public void put(T x) throws InterruptedException {
    lock.lock();
    try {
        while (count == items.length)
            notFull.await();
        items[tail] = x;
        if (++tail == items.length)
            tail = 0;
        ++count;
        notEmpty.signal();
    } finally {
        lock.unlock();
    }
}

public T take() throws InterruptedException {
    lock.lock();
    try {
        while (count == 0)
            notEmpty.await();
        T x = items[head];
        items[head] = null;
        if (++head == items.length)
            head = 0
        --count;
        notFull.signal();
        return x;
    } finally {
        lock.unlock();
    }
}
```

`signal`比`signalAll`更高效，它能极大地减少在每次缓存操作中发生上下文切换与锁请求的次数。

### AbstractQueuedSynchronizer

基于AQS构建的工具类：`ReentrantLock`, `Semaphore`, `CountDownLatch`, `ReentrantReadWriteLock`, `SynchronousQueue`, `FutureTask`。

AQS解决了实现同步器涉及的大量细节问题：FIFO队列（公平锁）。

AQS负责管理同步器中的状态，一个整数状态信息。可通过`getState`，`setState`以及`compareAndSetState`等`protected`类型方法进行操作。

+ `ReentrantLock`：所有者线程已经重复获取该锁的次数
+ `Semaphore`：剩余的许可数量
+ `FutureTask`：任务的状态（尚未开始、正在运行、已完成、已取消）

## 原子变量与非阻塞同步机制

非阻塞算法：用底层的原子机器指令代替锁来确保数据在并发访问中的一致性。使多个线程在竞争相同的数据时不会发生阻塞。不存在死锁、活跃性问题。

原子变量提供了与`volatile`类型相同的内存语义，此外还支持原子的更新操作。

### 锁的劣势

多个线程同时请求锁，一些线程将被挂起（借助os功能）并稍后运行。恢复执行时，必须等待其他线程执行完它们的时间片，才能被调度执行。挂起和恢复等过程存在很大的开销。

`volatile`是一种更轻量级的同步机制，但它只提供可见性，没有原子性。

其他缺点：线程在等待锁时，不能做其他事情。如果一个线程在持有锁的情况下被延迟执行（缺页错误、调度延迟），所有需要这个锁的线程都无法执行下去。

### 硬件对并发的支持

独占锁是一项悲观技术。对于细粒度操作，有一种更高效的乐观方法，可以在不发生干扰的情况下完成更新操作。

几乎所有的现代处理器中都包含了某种形式的原子读-改-写指令：比较并交换（Compare-and-Swap），关联加载/条件存储（Load-Linked/Store-Conditional）。

#### 比较并交换

CAS包含3个操作数-需要读写的内存位置V、进行比较的值A和拟写入的新值B。当且仅当V的值等于A时，才会通过原子方式用新值B来更新V的值，否则不会执行任何操作。结果始终返回V原有的值。

多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新成功，其他线程都将失败，但不会被挂起。失败后可以再次尝试或执行一些恢复操作，或不执行任何操作。大大减少活跃性风险。

```java
private SimulatedCAS value;

public int getValue() {
    return value.get();
}

public int increment() {
    int v;
    do {
        v = value.get();
    } while (v != value.compareAndSwap(v, v+1));
    return v+1;
}
```

CAS的主要缺点是，调用者处理竞争问题（重试、回退、放弃），而锁能自动处理竞争问题（线程获得锁之前将一直阻塞）。

大多数处理器上，在无竞争的锁获取和释放的“快速代码路径”上的开销，大约是CAS开销的两倍。

### 原子变量类

原子变量类相当于一种泛化的`volatile`变量，能够支持原子的和有条件的读-改-写操作。

标量类：`AtomicInteger`, `AtomicLong`, `AtomicBoolean`, `AtomicReference`。原子数组类中的元素可以实现原子更新。为数组的元素提供了`volatile`类型的访问语义

在高度竞争的情况下，锁的性能将超过原子变量的性能。而在更真实的竞争情况下（中低程度竞争），原子变量的性能超过锁的性能。锁在发生竞争时会挂起线程，从而降低CPU的使用率和共享内存总线上的同步通信量。原子变量在遇到竞争时立即重试（消耗CPU），在激烈竞争环境导致更多的竞争。

#### ABA问题

在CAS操作中将判断“V的值是否仍然为A？”，有时候还需要知道“自从上次看到V的值为A以来，这个值是否发生了变化？”

相对简单的解决方案：不是更新某个引用的值，而是更新两个值：引用、版本号。`AtomicStampedReference`, `AtomicMarkableReference

## Java内存模型

处理器可以采用乱序或并行等方式来执行指令；缓存可能会改变将写入变量提交到主内存的次序；保存在处理器本地缓存中的值，对于其他处理器是不可见的。Java语言规范要求JVM在线程中维护一种类似串行的语义：只要程序的最终结果与在严格串行环境中执行的结果相同，那么上述所有操作都是允许的。

多线程环境中，维护程序的串行性将导致很大的性能开销。只有要共享数据时，才必须协调它们之间的操作。

JMM为程序中所有的操作定义了一个偏序关系，称为Happens-Before。

+ **程序顺序规则**
+ **监视器锁规则**
+ **volatile变量规则**
+ **线程启动规则**
+ **线程借宿规则**
+ **中断规则**
+ **终结器规则**
+ **传递性**
