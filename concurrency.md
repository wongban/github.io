# Java Concurrency in Practice

1. **更快的执行**
    同一时间执行几个任务，不会因为某一任务计算量大而使整个程序等待它结束才能运行别的任务（阻塞）。两种实现方式：多CPU并行、单CPU时间分片。
2. **改进代码的设计**

## 线程安全性

线程安全性的定义中，最核心的概念就是正确性。正确性的含义是，某个类的行为与其规范完全一致。

当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。

无状态对象一定是线程安全的。

### 原子性

递增操作`++count`是一个复合操作。这是一个“读取-修改-写入”的操作序列，并且其结果状态依赖于之前的状态。

#### 竞态条件

当某个计算的正确性取决于多个线程的交替执行时序时，就会发生竞态条件。（正确的结果取决于运气）

最常见的竞态条件类型就是：

+ 先检查后执行(Check-Then-Act)：通过一个可能失效的观测结果来决定下一步动作。

  常见的情况：

  + 延迟初始化

    ```java
    public class LazyInitRace {
        private ExpensiveObject instance = null;
        public ExpensiveObject getInstance() {
            if (instance == null) instance = new ExpensiveObject();
            return instance;
        }
    }
    ```

  + 读取-修改-写入
        递增操作

当在无状态类中添加一个状态时，如果该状态完全由线程安全的对象来管理，那么这个类仍然是线程安全的。

当状态变量的数量由一个变为多个时，并不会像由零个变为一个那样简单。

### 加锁机制

#### 内置锁

内置锁是可重入的。某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。“重入”意味着获取锁的操作的粒度是“线程”，而不是“调用”。

### 用锁来保护状态

锁能够使其保护的代码路径以串行形式访问，因此可以通过锁来构造一些协议以实现对共享状态的独占访问。

仅仅将复合操作封装到一个同步代码块中是不够的。如果用同步来协调对某个变量的访问，那么在访问这个变量的所有位置上都需要使用同步。而且，当使用锁来协调对某个变量的访问时，在访问变量的所有位置上都要使用同一个锁。

如果在添加新的方法或代码路径时忘记了使用同步，那么这种加锁协议会很容易被破坏。

如果只是将每个方法都作为同步方法，例如`Vector`，那么并不足以确保`Vector`上复合操作都是原子的：`if (!vector.contains(element)) vector.add(element)`;

虽然`contains`和`add`等方法都是原子方法。但在上面这个“如果不存在则添加”的操作中仍然存在竞态条件。虽然`synchronized`方法可以确保单个操作的原子性，但如果要把多个操作合并为一个复合操作，还是需要额外的加锁机制。

### 活跃性和性能

要判断同步代码块的合理大小，需要在各种设计需求之间进行权衡，包括安全性（必须得到满足）、简单性和性能。

## 对象的共享

加锁的含义不仅仅局限于互斥行为，还包括内存可见性。

加锁机制既可以确保可见性又可以确保原子性，而`volatile`变量只能确保可见性。

当某个对象逸出后，你必须假设有某个类或线程可能会误用该对象。这正是需要使用封装的最主要原因：封装能够使得对程序的正确性进行分析变得可能，并使得无意中破坏设计约束条件变得更难。

### 不变性

在Java语言规范和Java内存模型中都没有给出不可变性的正式定义，但不可变性并不等于将对象中所有的域都声明为final类型，即使对象中所有的域都是final类型的，这个对象也仍然是可变的，因为在final类型的域中可以保存对可变对象的引用。

当满足以下条件时，对象才是不可变的：

+ 对象创建以后其状态就不能修改。
+ 对象的所有域都是final类型。
+ 对象是正确创建的（在对象的创建期间，this引用没有逸出）。

在不可变对象的内部仍可以使用可变对象来管理它们的状态。（这里主要注意第一个条件）

```java
public final class ThreeStooges {
    private final Set<String> stooges = new HashSet<String>();
    public ThreeStooges() {
        stooges.add("Moe");
    }
    public boolean isStooge(String name) {
        return stooges.contains(name);
    }
}
```

即使一个对象是可变的，通过将对象的某些域声明为final类型，仍然可以简化对其状态的推理，因为限制对象的可变性，相当于限制了它的可能状态集。

正如**除非需要更高的可见性，否则应将所有的域都声明为私有域**是一个良好的编程习惯，**除非需要某个域是可变的，否则应将其声明为`final`域**也是一个良好的编程习惯。

#### 不可变对象与初始化安全性

Java内存模型为不可变对象的共享提供了一种特殊的初始化安全性保证。

> 对于含有final域的对象，JVM必须保证对对象的初始引用在构造函数之后执行，不能乱序执行（out of order），也就是可以保证一旦你得到了引用，final域的值都是完成了初始化的，也就是书中所说的“初始化安全性”的保证。[来源](https://blog.csdn.net/ll530304349/article/details/52629254)

## 对象的组合

### 设计线程安全的类

如果对象中所有的域都是基本类型的变量，那么这些域将构成对象的全部状态。

如果在对象的域中引用了其他对象，那么该对象的状态将包含被引用对象的域。例如，`LinkedList`的状态就包括该链表中所有节点对象的状态。

## 中断和关闭

阻塞库方法(`Thread.sleep` `Object.wait`)都会检查线程何时中断，并且在发现中断时提前返回。它们在响应中断时执行的操作包括：清除中断状态，抛出`InterruptedException`，表示阻塞操作由于中断而提前结束。

## 线程池的使用

对于**计算密集型**（消化CPU资源）的任务，在拥有N个处理器的系统上，当线程池的大小为N+1时，通常能实现最优的利用率。（即使当计算密集型的线程偶尔由于页缺失故障或者其他原因而暂停时，这个“额外”的线程也能确保CPU的时钟周期不会被浪费。）。对于包含**I/O操作**或者其他**阻塞操作**的任务，由于线程并不会一直执行，因此线程池的规模应该更大。

## 显式锁

### Lock与ReentrantLock

```java
public interface Lock {
    // 无条件锁，等于使用synchronize
    void lock();
    void lockInterruptibly() throws InterruptedException;
    // 可轮询，可定时锁
    boolean tryLock();
    boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException;
    void unlock();
    Condition newCondition();
}
```

内置锁在功能上存在一些局限性（无法实现非阻塞结构）：

+ 无法中断一个正在等待获取锁的线程
+ 试图获得锁而不愿意永远等待它

`Lock`必须在`finally`块中释放锁。否则在被保护的代码中抛出异常，那么这个锁永远都无法释放。还必须考虑异常时，对象可能处于不一致状态（恢复不变性条件）。

`ReentrantLock`不能完全替代`synchronized`的原因：它更加危险，离开代码块不会自动清除锁。应该作为一种高级工具，在需要高级功能时才使用：可定时、可轮询、可中断，公平队列，非块结构。

#### 轮询锁与定时锁

内置锁出现死锁时恢复程序的唯一方法是重启，防止死锁的唯一方法是在构造程序时避免出现不一致的锁顺序。可定时、可轮询的锁提供了另一种选择：避免死锁发生。

轮询锁会在调用后立即返回，判断是否获得锁。可以使用轮询的方式来获取锁，并在循环了加上时间限制，来避免死锁发生。定时锁能如果不能在指定时间内给出结果，就会返回。

### 公平性

`ReentrantLock`的构造函数提供了两种公平性选择：创建非公平锁（默认）或公平锁。

+ 公平锁：线程按照它们发出请求的顺序来获得锁
+ 非公平锁：线程请求锁时，如果在发出请求的同时锁状态可以用，将跳过队列中的线程并获得锁（插队）

在非公平锁中，只有当锁被某个线程持有时，新发出请求的线程才会被放入队列中。

使用非公平锁的原因：可以提高性能。如果队列存在线程等待获得锁，接下来的请求也将会放到的队列中排队等待（挂起）。挂起-恢复这个过程存在着开销，而极大地降低性能。如果使用非公平锁，那么在发出请求时如果可用将直接获得，跳过了挂起-恢复的过程。在实际情况中，通常只需要保证被阻塞的线程能最终获得锁即可。依赖于公平的排队算法来确保正确性的情况并不常见。（不必要的话，不要为公平性付出代价）

恢复一个被挂起的线程与该线程真正开始运行之间存在着严重的延迟。

内置锁和默认的`ReentrantLock`一样不会提供确定的公平性保证。Java语言规范没有要求JVM以公平的方式来实现内置锁，而在各种JVM中也没有这样做。

### 读-写锁

```java
public interface ReadWriteLock {
    Lock readLock();
    Lock writeLock();
}
```

`ReentrantLock`是一种互斥锁，互斥通常是一种过于强硬的加锁机制，保守的加锁策略。虽然可以避免“写/写”，“写/读”冲突，但同样也避免了“读/读”冲突。而有些数据结构大多数访问操作都是读操作，允许多个执行读线程同时访问，将会提升性能。只要每个线程都能确保取到最新的数据，并且在读取数据时不会有其他的线程修改数据，那么就不会发生问题。一个资源可以被多个读操作访问，或者被一个写操作访问，但两者不能同时进行。

> `volatile`也能在一写多读的情况提供跟`ReadWriteLock`一样的特性，但`ReadWriteLock`还可以在多个写线程的情况下使用，写线程互斥。

与`Lock`一样，`ReadWriteLock`可以采用多种实现方式，这些方式在性能、调度保证、优先性、公平性以及加锁语义等方面可能有所不同：

+ **释放优先**。写入操作释放锁时，队列同时存在读写线程，应该优先选择哪种线程，还是最先发出请求的线程？
+ **读线程插队**。锁由读线程持有，但有写线程正在等待，新到达的读线程能否立即获得访问权，还是在写线程后面等待？允许将提高并发性，却可能造成写线程发生饥饿问题。
+ **重入性**。读锁和写锁是否是可重入的？
+ **降级**。持有写锁的线程能否在不释放的情况下获得读锁？（写锁“降级”为读锁），同时不允许其他写线程修改被保护的资源。
+ **升级**。读锁优先其他读写线程升级为写锁。大多数不支持升级，容易造成死锁。

```java
public class ReadWriteMap<K, V> {
    private final Map<K, V> map;
    private final ReadWriteLock lock = new ReentrantReadWriteLock();
    private final Lock r = lock.readLock();
    private final Lock w = lock.writeLock();

    public V put(K key, V value) {
        w.lock();
        try {
            return map.put(key, value);
        } finally {
            w.unlock();
        }
    }

    public V get(Object key) {
        r.lock();
        try {
            return map.get(key);
        } finally {
            r.unlock();
        }
    }
}
```

## 构建自定义的同步工具

构建状态依赖类的最简单方法是在类库中现有状态依赖类基础上构造。如果没有提供需要的功能，可以使用底层机制来构造自己的同步机制：条件队列、显式的`Condition`对象、`AbstractQueuedSynchronizer`框架。

### 状态依赖性的管理

并发对象上状态依赖的方法有时可以在不满足前置条件时失败，但通常有更好的替代方法：等待（阻塞）前置条件变为真。

构成前置条件的状态变量必须由对象的锁保护，以便在测试前置条件时保持不变。如果前置条件不成立，则必须释放锁定，以便另一个线程可以修改对象状态。

使用轮询和休眠虽然可以解决状态依赖问题，但效率不高：

```java
public void put(V v) throws InterruptedException {
    while (true) {
        synchronized (this) {
            if (!isNull()) {
                doPut(v);
                return;
            }
        }
        Thread.sleep(SLEEP_GRANULARITY);
        // 不进入休眠，则被成为忙等待或自旋等待。时间过长将会消耗大量CPU时间
        // 进入休眠，如果状态在`sleep`后就立即发生变化，将存在不必要的休眠时间
    }
}
```

#### 条件队列

“条件队列”：使得一组线程（等待线程集）能够通过某种方式来等待特定的条件变成真。传统队列的元素是数据，条件队列的元素是正在等待相关条件的线程。

